using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace MemoryPack.Editors
{
    public static class GenMemoryPackUnion
    {
        private static string GenRootPath = $"Assets/MemoryPack/Gen/";
        
        [InitializeOnLoadMethod]
        private static void Initialize()
        {
            // 获取所有需要处理的类
            var types = AppDomain.CurrentDomain.GetAssemblies()
                .SelectMany(assembly => assembly.GetTypes())
                .Where(t => t.GetCustomAttribute(typeof(MemoryPackableBaseClass)) != null)
                .ToList();

            for (int i = 0; i < types.Count; i++)
            {
                Generate(types[i]);
            }
        }
        
        public static void Generate(Type pGenType)
        {
            // 获取基类类型
            Type baseType = pGenType;

            // 获取所有子类（非抽象）
            var subTypes = AppDomain.CurrentDomain.GetAssemblies()
                .SelectMany(assembly => assembly.GetTypes())
                .Where(t => t != baseType && baseType.IsAssignableFrom(t) && !t.IsAbstract && !t.IsGenericType)
                .ToList();

            // 生成代码
            string code = GenerateCode(baseType, subTypes);

            // 写入文件
            if (!Directory.Exists(GenRootPath))
            {
                Directory.CreateDirectory(GenRootPath);
            }
            string filePath = Path.Combine(GenRootPath, $"{pGenType.Name}.cs");
            filePath = Path.GetFullPath(filePath);
            File.WriteAllText(filePath, code);

            Debug.Log($"生成MemoryPackUnion:{filePath}");
            
            // 刷新资源
            AssetDatabase.Refresh();
        }

        private static string GenerateCode(Type pBaseType, List<Type> pSubTypes)
        {
            string baseTypeNamespace = pBaseType.Namespace;
            string baseTypeName = pBaseType.Name;

            // 生成Union特性
            string unionAttributes = "";
            for (int i = 0; i < pSubTypes.Count; i++)
            {
                Type subType = pSubTypes[i];
                string fullName = subType.FullName;
                if (subType.IsGenericType)
                {
                    // 处理泛型类型，这里假设不需要泛型，因为上面过滤了
                    continue;
                }
                unionAttributes += $"[MemoryPackUnion({i}, typeof({fullName}))]\n    ";
            }

            return $@"// <auto-generated>
//     This code was generated by a tool.
//     Do not modify this file manually, or your changes will be lost.
// </auto-generated>

using MemoryPack;

namespace {baseTypeNamespace}
{{
    [MemoryPackable]
    {unionAttributes}
    public partial class {baseTypeName}
    {{
    }}
}}";
        }
    }
}